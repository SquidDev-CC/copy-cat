--- ComputerExecutor.java
+++ ComputerExecutor.java
@@ -52,7 +52,7 @@
  * One final responsibility for the executor is calling {@link ILuaAPI#update()} every tick, via the {@link #tick()}
  * method. This should only be called when the computer is actually on ({@link #isOn}).
  */
-final class ComputerExecutor {
+public final class ComputerExecutor {
     private static final Logger LOG = LoggerFactory.getLogger(ComputerExecutor.class);
     private static final int QUEUE_LIMIT = 256;
 
@@ -60,7 +60,7 @@
     private final ComputerEnvironment computerEnvironment;
     private final MetricsObserver metrics;
     private final List<ILuaAPI> apis = new ArrayList<>();
-    private final ComputerThread scheduler;
+    private final cc.tweaked.web.ComputerThread scheduler;
     final TimeoutState timeout;
 
     private @Nullable FileSystem fileSystem;
@@ -101,7 +101,7 @@
      * @see #enqueue()
      * @see #afterWork()
      */
-    volatile boolean onComputerQueue = false;
+    public volatile boolean onComputerQueue = false;
 
     /**
      * The amount of time this computer has used on a theoretical machine which shares work evenly amongst computers.
@@ -470,7 +470,7 @@
     /**
      * Called before calling {@link #work()}, setting up any important state.
      */
-    void beforeWork() {
+    public void beforeWork() {
         vRuntimeStart = System.nanoTime();
         timeout.startTimer();
     }
@@ -480,7 +480,7 @@
      *
      * @return If we have more work to do.
      */
-    boolean afterWork() {
+    public boolean afterWork() {
         if (interruptedEvent) {
             timeout.pauseTimer();
         } else {
@@ -506,7 +506,7 @@
      * @see #command
      * @see #eventQueue
      */
-    void work() throws InterruptedException {
+    public void work() throws InterruptedException {
         if (interruptedEvent && !closed) {
             interruptedEvent = false;
             if (machine != null) {
