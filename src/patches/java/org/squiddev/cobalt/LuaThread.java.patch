--- LuaThread.java
+++ LuaThread.java
@@ -63,7 +63,6 @@
 	 * Interval in nanoseconds at which to check for lua threads that are no longer referenced.
 	 * This can be changed by Java startup code if desired.
 	 */
-	public static long orphanCheckInterval = TimeUnit.SECONDS.toNanos(30);
 
 	/**
 	 * A coroutine which has been run at all
@@ -262,11 +261,7 @@
 		if (state.currentThread.state.javaCount == 0) {
 			throw UnwindThrowable.yield(args);
 		} else {
-			try {
-				return yieldBlockingImpl(state, args);
-			} catch (InterruptedException e) {
-				throw new InterruptedError(e);
-			}
+			throw new LuaError("attempt to yield across a call boundary");
 		}
 	}
 
@@ -279,11 +274,13 @@
 	 * @throws LuaError             If this thread cannot be yielded.
 	 * @throws InterruptedException If this thread was terminated when yielding.
 	 */
+	/*
 	public static Varargs yieldBlocking(LuaState state, Varargs args) throws LuaError, InterruptedException {
 		Objects.requireNonNull(args, "args cannot be null");
 		checkYield(state);
 		return yieldBlockingImpl(state, args);
 	}
+	*/
 
 	private static void checkYield(LuaState state) throws LuaError {
 		LuaThread thread = state.currentThread;
@@ -293,6 +290,7 @@
 		if (thread.isMainThread()) throw new LuaError("cannot yield main thread");
 	}
 
+	/*
 	private static Varargs yieldBlockingImpl(LuaState state, Varargs args) throws InterruptedException, LuaError {
 		State current = state.currentThread.state;
 
@@ -302,6 +300,7 @@
 		current.previousThread = null;
 		return transferControl(state, current, args);
 	}
+	*/
 
 	/**
 	 * Resume a thread with arguments.
@@ -328,6 +327,7 @@
 		if (currentState.javaCount == 0) {
 			throw UnwindThrowable.resume(thread, args);
 		} else {
+			/*
 			try {
 				// Mark the child coroutine as "active", and transfer.
 				state.currentThread = thread;
@@ -342,6 +342,8 @@
 			} catch (InterruptedException e) {
 				throw new InterruptedError(e);
 			}
+			*/
+			throw new LuaError("attempt to resume across a call boundary");
 		}
 	}
 
@@ -361,7 +363,7 @@
 		if (current.javaCount == 0) {
 			throw UnwindThrowable.suspend();
 		} else {
-			suspendBlocking(state);
+			throw new LuaError("attempt to yield across a call boundary");
 		}
 	}
 
@@ -371,6 +373,7 @@
 	 * @param state The current lua state
 	 * @throws LuaError If this coroutine cannot be suspended.
 	 */
+	/*
 	public static void suspendBlocking(LuaState state) throws LuaError {
 		State current = state.currentThread.state;
 		if (current.status != STATUS_RUNNING) {
@@ -412,6 +415,7 @@
 			thread.needsThreadedResume = false;
 		}
 	}
+	*/
 
 	public static Varargs runMain(LuaState state, LuaFunction function) throws LuaError, InterruptedException {
 		return run(state, state.getMainThread(), function, Constants.NONE);
@@ -434,6 +438,7 @@
 	}
 
 	private static Varargs run(final LuaState state, LuaThread thread, LuaFunction function, Varargs args) throws LuaError, InterruptedException {
+		/*
 		YieldThreader threader = state.threader;
 		threader.lock.lock();
 		try {
@@ -491,11 +496,11 @@
 		} finally {
 			threader.lock.unlock();
 		}
+		*/
+		return loop(state, thread, function, args);
 	}
 
-	static Varargs loop(final LuaState state, LuaThread thread, LuaFunction function, Varargs args) throws LuaError, TransferredControlThrowable {
-		YieldThreader threader = state.threader;
-
+	static Varargs loop(final LuaState state, LuaThread thread, LuaFunction function, Varargs args) throws LuaError {
 		LuaError le = null;
 		do {
 			final State threadState = thread.state;
@@ -521,6 +526,7 @@
 						args = null;
 						le = LuaError.wrap(e);
 					}
+				/*
 				} else if (threadState.needsThreadedResume) {
 					// We only ever resume coroutines which have yielded, never those which have
 					// resumed other coroutines. Consequently, we know we will never have an error here.
@@ -534,6 +540,7 @@
 					threadState.resumeLock.signal();
 
 					throw TransferredControlThrowable.INSTANCE;
+				*/
 				} else {
 					threadState.status = STATUS_RUNNING;
 
@@ -658,12 +665,10 @@
 		/**
 		 * The lock to wait on while this coroutine is suspended as a thread
 		 */
-		Condition resumeLock;
 
 		/**
 		 * Whether we've yielded in a threaded manner.
 		 */
-		boolean needsThreadedResume;
 
 		/**
 		 * Constructor for main thread only
